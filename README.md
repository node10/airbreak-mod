### Original Airbreak readme [here](README_ORIG.md).

### This fork is intended to:
- Adjust the patcher to work on the Aircurve 10 S ASV, hardware model 37162 and firmware version SX567-0401.  
- Remove all optional modification options aside from the graph.c replacement code to support firmware modification from a known working modified state.  
- Serve as documentation of progress towards the goal of automating daily session data exfiltration.  

### A makeshift modification/compilation/flashing/debugging envrionment is set up as follows:
- An [STLINK-V3MINIE](https://www.st.com/en/development-tools/stlink-v3minie.html) STM32 programmer/debugger.
    - This is connected to the debugging header as described at [airbreak/disassembly](https://airbreak.dev/disassembly/). As per the Warning on the page, the genuine STLINK needs ```STM32_VDD``` on the machine connected to ```T_VCC``` on the STLINK so the STLINK can detect the target voltage.
- The [OpenOCD](https://openocd.org/) project setup as described at [airbreak/firmware](https://airbreak.dev/firmware/). Namely, running this command as root from the project folder:
    ```Shell
    openocd -f interface/stlink-v2.cfg -f 'tcl/airsense.cfg'
    ```
    - When using the STLINK-V3MINIE, ```stlink-v2.cfg``` is replaced with ```stlink.cfg```
    - Both telnet and gdb are connected to OpenOCD via these commands in different terminal windows:  
    ```telnet localhost 4444```  
    ```gdb``` and then once in gbd's terminal, ```target extended-remote localhost:3333```  
    gdb ```halt```'s the target on connect by default, so the machine will stop working until the ```continue``` command is issued in gdb once that happens. ```Ctrl-C``` will ```halt``` the machine's cpu so breakpoints and other debugging can be set up.
- [Ghidra](https://github.com/NationalSecurityAgency/ghidra) for decompiling the binary firmware
    - The binary firmware dumped via the STLINK is imported into Ghidra, choosing Cortex M little endian as the language, and setting the Base address at ```0x08000000```.
    - Before letting it analyze the binary, add entries to the Memory Map.
        - SRAM starts at ```0x20000000``` and is ```0x20000``` in size.
        - Using the SVD-loader extension to load ```STM32F405.svd``` downloaded from an SVD repository will automate adding the rest of the relevant memory address space.
    - The Airbreak repository contains a Ghidra2stubs script and a stubs.S file, but does not include the original xml from Ghidra. The stubs.S file can be used to cross-reference functions seen in Ghidra (although they will be off by 1 due to Thumb code).

The Debugger is connected to a virtual machine running Ubuntu Server with SSH access.
There are 2 interfaces exposed by OpenOCD that are used, the GDB debugging interface on port 3333 and a telnet interface for running commands on port 4444.  
One advantage of the telnet interface is the ability to dump memory from the target while it is stays running. Knowing the needed data most likely sits in RAM before being written to the SD card, dumps are taken of the entire 128KB ram address space at various points during a test run using this command while redirecting telnet stdout to a file:  
```mdd 0x20000000 8000```  
This will output 8000 64-bit doublewords (128KB). Output is formatted so it can be converted from hex to ascii to search for human-readable strings.  

Starting at address ```0x2000d5b0```, data that looks similar to what is found within the EDF files on the sd card can be seen occasionally during a session. A watchpoint is set on that address in gdb and a session is started. Gdb instantly breaks at ```0x08068556``` and this provides a starting point to look for interesting functions. Ghidra is used from here to search around this address for functions and labels that use this part of code to write data that hopefully eventually ends up on the SD card. ```0x08068556``` sits within the function ```0x0806854c``` and stubs.S contains a function at the Thumb address (```0x0806854d```) titled "file_something". Searching for reference calls to this function in ghidra shows 49 other functions. The goal at this point is to follow the tree of functions to find the one that takes a specific string and writes it to an address found in a memory dump. This involves setting a breakpoint at that address in ghidra, dumping bytes starting at ```0x2000d5b0``` and viewing the ascii representation to find relevant strings. In gdb, custom user functions can be assigned and this was used to assign the shortcut 'c', normally shorthand for 'continue', to first dump memory to file, then continue. On another terminal window, ```watch -n 0.2 hexdump -C memory.bin``` is quickly showing changes to the memory dump ```memory.bin``` to automatically show new memory dumps as ascii. At ```0x2000d5d0```, the characters 'bpm' as ascii bytes are occasionally written during a session. Although a discovery is made where a function is found that seemed to only write chunks of strings that eventually find their way to files on the SD card, that function address was not recorded anywhere and later attempts were unsuccessful in finding that address using the same methods. A list of about 100 candidate addresses were later checked through breakpoints unsuccessfully as well.  
It was discovered that readable strings written to that address were first written at the start of a session, but then not again for about a minute. This delayed function searching as a session on the machine would have to run for over a minute to verify whether the address was relevant. The project would then pivot to modifying the graph.c extension to change the display when the bytes of 'bpm' were written. At first, the snprintf function at ```0x0806d499``` was used to simply print bytes at that memory address every iteration. Unfortunately, this function would crash the cpu instantly and cause the machine to reset. Inside graph.c, a pointer is set to ```0x2000d5b0```, which would take the 4 bytes starting at that address and interpret them as an integer. Next, the GUI_SetColor() function that would set the background color was changed to the integer instead. Running this code resulted in the background color behind the graph rapidly changing as those bytes were interpreted as various colors. The display would then stay black for roughly a minute before rapidly changing colors again. This confirmed that there were gaps in time of about a minute where no data is written (i.e. it stays all zeros, which would be the color black) to that location. Next, adjustments were made instead to compare and match the bytes to 'bpm' and change the background color to a full red to make it obvious when they appeared.